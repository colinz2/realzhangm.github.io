<!doctype html><html lang=zh><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Tcpreplay使用Netmap发包 - zhangm blog</title><meta name=description content="说明 Tcprepaly是一个报文回放工具，可以将使用 .pcap 文件保存的报文回放。
Tcpreplay默认使用使用的标准的Linux系统API来发包的，发包速度较慢。Netmap是一种高效的收发报文的 I/O 框架，可以使用其API直接在用户态完成数据包到网卡的拷贝，即「内核旁路技术」[1][2]，从而大大提高发包效率。下面介绍了Tcpreplay使用Netmap的编译步骤。关于Tcprepaly和Netmap 的更是信息可以参考各自的官网。
Netmap 1). 下载Netmap代码
git clone https://github.com/luigirizzo/netmap 2). 编译Netmap
./configure --drivers=i40e make 3). 安装Netmap模块
# rmmod i40e # insmod ./netmap.ko # insmod ./i40e/i40e.ko ./configure --drivers=ixgbe # rmmod ixgbe # insmod ./netmap.ko # insmod ./ixgbe/ixgbe.ko Tcpreplay 1). 下载代码
git clone https://github.com/appneta/tcpreplay 2). 编译安装
./configure --with-netmap=/home/zhangm/test/netmap/ make && make install 3). 使用
使用Tcpreplay时增加 &ndash;netmap 参数, 则使用 Netmap 模式
如:
tcpreplay -i ens1f0 -tK --loop 50000 --netmap /home/zhangm/pcap/bigFlows."><meta name=author content><link rel="preload stylesheet" as=style href=https://realzhangm.github.io/app.min.css><link rel="preload stylesheet" as=style href=https://realzhangm.github.io/an-old-hope.min.css><script defer src=https://realzhangm.github.io/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><link rel=preload as=image href=https://realzhangm.github.io/theme.png><link rel=preload as=image href=https://realzhangm.github.io/github.svg><link rel=icon href=https://realzhangm.github.io/favicon.ico><link rel=apple-touch-icon href=https://realzhangm.github.io/apple-touch-icon.png><meta name=generator content="Hugo 0.85.0"><meta property="og:title" content="Tcpreplay使用Netmap发包"><meta property="og:description" content="Tcpreplay使用Netmap模式的步骤"><meta property="og:type" content="article"><meta property="og:url" content="https://realzhangm.github.io/posts/tcpreplay%E4%BD%BF%E7%94%A8netmap%E5%8F%91%E5%8C%85/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-01-14T09:28:42+08:00"><meta property="article:modified_time" content="2018-01-14T09:28:42+08:00"><meta itemprop=name content="Tcpreplay使用Netmap发包"><meta itemprop=description content="Tcpreplay使用Netmap模式的步骤"><meta itemprop=datePublished content="2018-01-14T09:28:42+08:00"><meta itemprop=dateModified content="2018-01-14T09:28:42+08:00"><meta itemprop=wordCount content="209"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Tcpreplay使用Netmap发包"><meta name=twitter:description content="Tcpreplay使用Netmap模式的步骤"></head><body class=not-ready data-menu=true><header class=header><p class=logo><a class=site-name href=https://realzhangm.github.io>zhangm blog</a><a class=btn-dark></a></p><script>let bodyClx=document.body.classList,btnDark=document.querySelector('.btn-dark'),sysDark=window.matchMedia('(prefers-color-scheme: dark)'),darkVal=localStorage.getItem('dark'),setDark=a=>{bodyClx[a?'add':'remove']('dark'),localStorage.setItem('dark',a?'yes':'no')};setDark(darkVal?darkVal==='yes':sysDark.matches),requestAnimationFrame(()=>bodyClx.remove('not-ready')),btnDark.addEventListener('click',()=>setDark(!bodyClx.contains('dark'))),sysDark.addEventListener('change',a=>setDark(a.matches))</script><nav class=menu><a href=/about/>About</a></nav><nav class=social><a class=github style=--url:url(./github.svg) href=https://github.com/realzhangm target=_blank></a></nav></header><main class=main><article class=post-single><header class=post-title><p><time>:date_medium</time></p><h1>Tcpreplay使用Netmap发包</h1></header><section class=post-content><h1 id=说明>说明</h1><p>Tcprepaly是一个报文回放工具，可以将使用 .pcap 文件保存的报文回放。</p><p>Tcpreplay默认使用使用的标准的Linux系统API来发包的，发包速度较慢。Netmap是一种高效的收发报文的 I/O 框架，可以使用其API直接在用户态完成数据包到网卡的拷贝，即「内核旁路技术」[<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>][<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>]，从而大大提高发包效率。下面介绍了Tcpreplay使用Netmap的编译步骤。关于Tcprepaly和Netmap 的更是信息可以参考各自的官网。</p><h1 id=netmap>Netmap</h1><p>1). 下载Netmap代码</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>git clone https://github.com/luigirizzo/netmap
</code></pre></div><p>2). 编译Netmap</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>./configure --drivers<span style=color:#f92672>=</span>i40e
make
</code></pre></div><p>3). 安装Netmap模块</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#75715e># rmmod i40e</span>
<span style=color:#75715e># insmod ./netmap.ko</span>
<span style=color:#75715e># insmod ./i40e/i40e.ko</span>

./configure --drivers<span style=color:#f92672>=</span>ixgbe
<span style=color:#75715e># rmmod ixgbe</span>
<span style=color:#75715e># insmod ./netmap.ko</span>
<span style=color:#75715e># insmod ./ixgbe/ixgbe.ko</span>
</code></pre></div><h2 id=tcpreplay>Tcpreplay</h2><p>1). 下载代码</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>git clone https://github.com/appneta/tcpreplay
</code></pre></div><p>2). 编译安装</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>./configure --with-netmap<span style=color:#f92672>=</span>/home/zhangm/test/netmap/
make <span style=color:#f92672>&amp;&amp;</span> make install
</code></pre></div><p>3). 使用</p><p>使用Tcpreplay时增加 &ndash;netmap 参数, 则使用 Netmap 模式</p><p>如:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>tcpreplay -i ens1f0 -tK --loop <span style=color:#ae81ff>50000</span> --netmap /home/zhangm/pcap/bigFlows.pcap
</code></pre></div><p>-K, &ndash;preload-pcap Preloads packets into RAM before sending //提升效率</p><h2 id=附>附:</h2><h5 id=如何获取网卡驱动名称-如-ens1f0-接口>如何获取网卡驱动名称, 如 ens1f0 接口?</h5><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#f92672>[</span>root@localhost build<span style=color:#f92672>]</span><span style=color:#75715e># ethtool -i ens1f0</span>
driver: i40e
version: 2.3.6
firmware-version: 5.05 0x8000288a 0.0.0
expansion-rom-version: 
bus-info: 0000:02:00.0
supports-statistics: yes
supports-test: yes
supports-eeprom-access: yes
supports-register-dump: yes
supports-priv-flags: yes
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#f92672>[</span>root@localhost build<span style=color:#f92672>]</span><span style=color:#75715e># lspci  | grep Eth</span>
01:00.0 Ethernet controller: Intel Corporation I350 Gigabit Network Connection <span style=color:#f92672>(</span>rev 01<span style=color:#f92672>)</span>
01:00.1 Ethernet controller: Intel Corporation I350 Gigabit Network Connection <span style=color:#f92672>(</span>rev 01<span style=color:#f92672>)</span>
02:00.0 Ethernet controller: Intel Corporation Ethernet Controller X710 <span style=color:#66d9ef>for</span> 10GbE SFP+ <span style=color:#f92672>(</span>rev 02<span style=color:#f92672>)</span>
02:00.1 Ethernet controller: Intel Corporation Ethernet Controller X710 <span style=color:#66d9ef>for</span> 10GbE SFP+ <span style=color:#f92672>(</span>rev 02<span style=color:#f92672>)</span>
02:00.2 Ethernet controller: Intel Corporation Ethernet Controller X710 <span style=color:#66d9ef>for</span> 10GbE SFP+ <span style=color:#f92672>(</span>rev 02<span style=color:#f92672>)</span>
02:00.3 Ethernet controller: Intel Corporation Ethernet Controller X710 <span style=color:#66d9ef>for</span> 10GbE SFP+ <span style=color:#f92672>(</span>rev 02<span style=color:#f92672>)</span>
<span style=color:#f92672>[</span>root@localhost build<span style=color:#f92672>]</span><span style=color:#75715e># lspci  -s 02:00.0 -vvv | grep driver</span>
    Kernel driver in use: i40e
</code></pre></div><h2 id=参考>参考：</h2><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>1:<a href=https://blog.cloudflare.com/kernel-bypass/>https://blog.cloudflare.com/kernel-bypass/</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p>2:<a href=http://blog.csdn.net/fengfengdiandia/article/details/52594758>http://blog.csdn.net/fengfengdiandia/article/details/52594758</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></section><nav class=post-nav><a class=prev href=https://realzhangm.github.io/posts/cc++%E7%A8%8B%E5%BA%8F%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7/><span>←</span><span>C/C++代码检查&运行时检查工具</span></a></nav></article></main><footer class=footer><p>&copy; 2022 <a href=https://realzhangm.github.io>zhangm blog</a></p><p>Powered by <a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>️</p><p><a href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>Paper 5.1</a></p></footer></body></html>