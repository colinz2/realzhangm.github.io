<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>zhangm blog</title><link>https://realzhangm.github.io/</link><description>Recent content on zhangm blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2018–2022, zhangm; all rights reserved.</copyright><lastBuildDate>Fri, 08 Apr 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://realzhangm.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>【转】Naming cheatsheet</title><link>https://realzhangm.github.io/post/naming_cheatsheet/</link><pubDate>Fri, 08 Apr 2022 00:00:00 +0000</pubDate><guid>https://realzhangm.github.io/post/naming_cheatsheet/</guid><description>原文
Naming cheatsheet English language Naming convention S-I-D Avoid contractions Avoid context duplication Reflect the expected result Naming functions A/HC/LC pattern Actions Context Prefixes Singular and Plurals Naming things is hard. This sheet attempts to make it easier.
Although these suggestions can be applied to any programming language, I will use JavaScript to illustrate them in practice.
English language Use English language when naming your variables and functions.</description></item><item><title>Websocket 协议分析</title><link>https://realzhangm.github.io/post/websocket%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/</link><pubDate>Sun, 27 Mar 2022 20:10:23 +0800</pubDate><guid>https://realzhangm.github.io/post/websocket%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/</guid><description>简述 Websocket 协议建立 Websocket 协议的建立是客户端与服务端通过 HTTP 的 Update 机制完成的。即将当前的 HTTP 协议升级为 websockt 协议，这样一来，websockt 可以复用 HTTP 的连接。
总结如下：
1. 协议握手，HTTP update 机制 2. 协议建立，可以通过 websocket 双向数据传输了 握手流程 客户端请求协议升级 服务端响应升级状态 具的报文如下：
The handshake from the client looks as follows: GET /chat HTTP/1.1 Host: server.example.com Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== Origin: http://example.com Sec-WebSocket-Protocol: chat, superchat Sec-WebSocket-Version: 13 The handshake from the server looks as follows: HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo= Sec-WebSocket-Protocol: chat 其中客户端报文携带的 header 字段: Sec-WebSocket-Key ：必传， 由客户端随机生成的 16 字节值, 然后做 base64 编码, 客户端需要保证该值是足够随机, 不可被预测的</description></item><item><title>Install k8s with sealos</title><link>https://realzhangm.github.io/post/install_k8s_with_sealos/</link><pubDate>Mon, 08 Nov 2021 20:10:23 +0800</pubDate><guid>https://realzhangm.github.io/post/install_k8s_with_sealos/</guid><description>说明 本文记录了使用 sealos 安装 k8s 的过程，其中虚拟机使用 vagrant 来配置。
安装 vagrant 可以参考 vagrant 官网。
curl -fsSL https://apt.releases.hashicorp.com/gpg | sudo apt-key add - sudo apt-add-repository &amp;#34;deb [arch=amd64] https://apt.releases.hashicorp.com $(lsb_release -cs)main&amp;#34; sudo apt-get update &amp;amp;&amp;amp; sudo apt-get install vagrant 入门参考，点这里
使用 vagrant 启动虚拟机 以下为 Vagrantfile 文件，在这个文件的相同目录下可以执行 vagrant 命令。如，启动虚拟机 vagrant up 。
# -*- mode: ruby -*- # vi: set ft=ruby : # All Vagrant configuration is done below. The &amp;#34;2&amp;#34; in Vagrant.configure # configures the configuration version (we support older styles for # backwards compatibility).</description></item><item><title>About</title><link>https://realzhangm.github.io/about/</link><pubDate>Sat, 28 Mar 2020 00:00:00 +0000</pubDate><guid>https://realzhangm.github.io/about/</guid><description>journey title 我的一天 section 上班 有时开会: 3: 我,同事 Coding: 5: 我 项目流程: 2: 我 section 下班 看书: 5: 我 上网: 5: 我</description></item><item><title/><link>https://realzhangm.github.io/archives/</link><pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate><guid>https://realzhangm.github.io/archives/</guid><description/></item><item><title>Tcpreplay使用Netmap发包</title><link>https://realzhangm.github.io/post/tcpreplay%E4%BD%BF%E7%94%A8netmap%E5%8F%91%E5%8C%85/</link><pubDate>Thu, 01 Nov 2018 00:00:00 +0000</pubDate><guid>https://realzhangm.github.io/post/tcpreplay%E4%BD%BF%E7%94%A8netmap%E5%8F%91%E5%8C%85/</guid><description>说明 Tcprepaly是一个报文回放工具，可以将使用 .pcap 文件保存的报文回放。
Tcpreplay默认使用使用的标准的Linux系统API来发包的，发包速度较慢。Netmap是一种高效的收发报文的 I/O 框架，可以使用其API直接在用户态完成数据包到网卡的拷贝，即「内核旁路技术」[1][2]，从而大大提高发包效率。下面介绍了Tcpreplay使用Netmap的编译步骤。关于Tcprepaly和Netmap 的更是信息可以参考各自的官网。
Netmap 1). 下载Netmap代码
git clone https://github.com/luigirizzo/netmap 2). 编译Netmap
./configure --drivers=i40e make 3). 安装Netmap模块
# rmmod i40e # insmod ./netmap.ko # insmod ./i40e/i40e.ko ./configure --drivers=ixgbe # rmmod ixgbe # insmod ./netmap.ko # insmod ./ixgbe/ixgbe.ko Tcpreplay 1). 下载代码
git clone https://github.com/appneta/tcpreplay 2). 编译安装
./configure --with-netmap=/home/zhangm/test/netmap/ make &amp;amp;&amp;amp; make install 3). 使用
使用Tcpreplay时增加 &amp;ndash;netmap 参数, 则使用 Netmap 模式
如:
tcpreplay -i ens1f0 -tK --loop 50000 --netmap /home/zhangm/pcap/bigFlows.</description></item><item><title>C/C++代码检查&amp;运行时检查工具</title><link>https://realzhangm.github.io/post/cc++%E7%A8%8B%E5%BA%8F%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7/</link><pubDate>Sun, 14 Jan 2018 00:00:00 +0000</pubDate><guid>https://realzhangm.github.io/post/cc++%E7%A8%8B%E5%BA%8F%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7/</guid><description>静态代码检查工具 scan-build 在源码目录下执行make
scan-build make REF http://clang-analyzer.llvm.org/
infer linux下安装 VERSION=0.XX.Y; \ curl -sSL &amp;#34;https://github.com/facebook/infer/releases/download/v$VERSION/infer-linux64-v$VERSION.tar.xz&amp;#34; \ | sudo tar -C /opt -xJ &amp;amp;&amp;amp; \ ln -s &amp;#34;/opt/infer-linux64-v$VERSION/bin/infer&amp;#34; /usr/local/bin/infer mac下安装 brew install infer 使用 在源码目录下执行make
infer run -- make 运行时工具 谷歌sanitizers 谷歌sanitizers系列工具用于程序内存分析. (https://github.com/google/sanitizers) sanitizers以库的形式使用. GCC, Clang等编译器都已经集成, 编译程序时使用特定参数(-fsanitize=leak), 会将特定代码自动插入到程序中, 并链接sanitizers库. LeakSanitizer用于内存泄漏分析. GCC5.3以上支持LeakSanitizer.
例如使用gcc -fsanitize=leak 编译的程序. 通过SIGINT等信号退出程序, 分析结果会自动打印到终端
查看test进程内存使用大小
cat /proc/pidof test/status | grep VmRSS: REF http://fbinfer.com/docs/getting-started.html
https://github.com/google/sanitizers/wiki</description></item></channel></rss>