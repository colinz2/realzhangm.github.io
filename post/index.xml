<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on zhangm blog</title><link>https://realzhangm.github.io/post/</link><description>Recent content in Posts on zhangm blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright © 2018–2022, zhangm; all rights reserved.</copyright><lastBuildDate>Thu, 01 Nov 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://realzhangm.github.io/post/index.xml" rel="self" type="application/rss+xml"/><item><title>Tcpreplay使用Netmap发包</title><link>https://realzhangm.github.io/post/tcpreplay%E4%BD%BF%E7%94%A8netmap%E5%8F%91%E5%8C%85/</link><pubDate>Thu, 01 Nov 2018 00:00:00 +0000</pubDate><guid>https://realzhangm.github.io/post/tcpreplay%E4%BD%BF%E7%94%A8netmap%E5%8F%91%E5%8C%85/</guid><description>说明 Tcprepaly是一个报文回放工具，可以将使用 .pcap 文件保存的报文回放。
Tcpreplay默认使用使用的标准的Linux系统API来发包的，发包速度较慢。Netmap是一种高效的收发报文的 I/O 框架，可以使用其API直接在用户态完成数据包到网卡的拷贝，即「内核旁路技术」[1][2]，从而大大提高发包效率。下面介绍了Tcpreplay使用Netmap的编译步骤。关于Tcprepaly和Netmap 的更是信息可以参考各自的官网。
Netmap 1). 下载Netmap代码
git clone https://github.com/luigirizzo/netmap 2). 编译Netmap
./configure --drivers=i40e make 3). 安装Netmap模块
# rmmod i40e # insmod ./netmap.ko # insmod ./i40e/i40e.ko ./configure --drivers=ixgbe # rmmod ixgbe # insmod ./netmap.ko # insmod ./ixgbe/ixgbe.ko Tcpreplay 1). 下载代码
git clone https://github.com/appneta/tcpreplay 2). 编译安装
./configure --with-netmap=/home/zhangm/test/netmap/ make &amp;amp;&amp;amp; make install 3). 使用
使用Tcpreplay时增加 &amp;ndash;netmap 参数, 则使用 Netmap 模式
如:
tcpreplay -i ens1f0 -tK --loop 50000 --netmap /home/zhangm/pcap/bigFlows.</description></item><item><title>C/C++代码检查&amp;运行时检查工具</title><link>https://realzhangm.github.io/post/cc++%E7%A8%8B%E5%BA%8F%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7/</link><pubDate>Sun, 14 Jan 2018 00:00:00 +0000</pubDate><guid>https://realzhangm.github.io/post/cc++%E7%A8%8B%E5%BA%8F%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7/</guid><description>静态代码检查工具 scan-build 在源码目录下执行make
scan-build make REF http://clang-analyzer.llvm.org/
infer linux下安装 VERSION=0.XX.Y; \ curl -sSL &amp;#34;https://github.com/facebook/infer/releases/download/v$VERSION/infer-linux64-v$VERSION.tar.xz&amp;#34; \ | sudo tar -C /opt -xJ &amp;amp;&amp;amp; \ ln -s &amp;#34;/opt/infer-linux64-v$VERSION/bin/infer&amp;#34; /usr/local/bin/infer mac下安装 brew install infer 使用 在源码目录下执行make
infer run -- make 运行时工具 谷歌sanitizers 谷歌sanitizers系列工具用于程序内存分析. (https://github.com/google/sanitizers) sanitizers以库的形式使用. GCC, Clang等编译器都已经集成, 编译程序时使用特定参数(-fsanitize=leak), 会将特定代码自动插入到程序中, 并链接sanitizers库. LeakSanitizer用于内存泄漏分析. GCC5.3以上支持LeakSanitizer.
例如使用gcc -fsanitize=leak 编译的程序. 通过SIGINT等信号退出程序, 分析结果会自动打印到终端
查看test进程内存使用大小
cat /proc/pidof test/status | grep VmRSS: REF http://fbinfer.com/docs/getting-started.html
https://github.com/google/sanitizers/wiki</description></item></channel></rss>